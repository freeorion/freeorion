# Autogenerated do not modify manually!
# This is a type-hinting python stub file, used by python IDEs to provide type hints. For more information
# about stub files, see https://www.python.org/dev/peps/pep-0484/#stub-files
# During execution, the actual module is made available via
# a C++ Boost-python process as part of the launch.
from typing import Dict


class AccountingInfoVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class EffectCause:
    @property
    def causeType(self):
        ...

    @property
    def customLabel(self):
        ...

    @property
    def specificCause(self):
        ...


class GGColor:
    @property
    def a(self)-> int:
        ...

    @property
    def b(self)-> int:
        ...

    @property
    def g(self)-> int:
        ...

    @property
    def r(self)-> int:
        ...


class GalaxySetupData:
    @property
    def age(self)-> galaxySetupOption:
        ...

    @property
    def gameUID(self)-> str:
        ...

    @property
    def maxAIAggression(self)-> aggression:
        ...

    @property
    def monsterFrequency(self)-> galaxySetupOption:
        ...

    @property
    def nativeFrequency(self)-> galaxySetupOption:
        ...

    @property
    def planetDensity(self)-> galaxySetupOption:
        ...

    @property
    def seed(self)-> str:
        ...

    @property
    def shape(self)-> galaxyShape:
        ...

    @property
    def size(self)-> int:
        ...

    @property
    def specialsFrequency(self)-> galaxySetupOption:
        ...

    @property
    def starlaneFrequency(self)-> galaxySetupOption:
        ...


class GameRules:
    @property
    def empty(self):
        ...

    def getDescription(self, string: str) -> str:
        ...

    def getDouble(self, string: str) -> float:
        ...

    def getInt(self, string: str) -> int:
        ...

    def getRulesAsStrings(self) -> StringsMap:
        ...

    def getString(self, string: str) -> str:
        ...

    def getToggle(self, string: str) -> bool:
        ...

    def ruleExists(self, string: str) -> bool:
        ...

    def ruleExistsWithType(self, string: str, rule_type: ruleType) -> bool:
        ...


class IntBoolMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class IntDblMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class IntFltMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class IntIntMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class IntPairVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class IntSet:
    def __contains__(self, number: int) -> bool:
        ...

    def __iter__(self) -> iter:
        ...

    def __len__(self) -> int:
        ...

    def count(self, number: int) -> int:
        ...

    def empty(self) -> bool:
        ...

    def size(self) -> int:
        ...


class IntSetSet:
    def __contains__(self, int_set: IntSet) -> bool:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def count(self, int_set: IntSet) -> int:
        ...

    def empty(self) -> bool:
        ...

    def size(self) -> int:
        ...


class IntVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> iter:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class MeterTypeAccountingInfoVecMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class MeterTypeMeterMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class MeterTypeStringPair:
    @property
    def meterType(self):
        ...

    @property
    def string(self):
        ...


class Order:
    @property
    def empireID(self):
        ...

    @property
    def executed(self):
        ...


class OrderSet:
    @property
    def size(self):
        ...

    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class PairIntInt_IntMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class ShipPartMeterMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class ShipSlotVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class StringSet:
    def __contains__(self, string: str) -> bool:
        ...

    def __iter__(self) -> iter:
        ...

    def __len__(self) -> int:
        ...

    def count(self, string: str) -> int:
        ...

    def empty(self) -> bool:
        ...

    def size(self) -> int:
        ...


class StringVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> iter:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class StringsMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class TargetIDAccountingMapMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class UnlockableItem:
    @property
    def name(self)-> str:
        ...

    @property
    def type(self)-> unlockableItemType:
        ...


class UnlockableItemVec:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> iter:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...

    def append(self, obj: object) -> None:
        ...

    def extend(self, obj: object) -> None:
        ...


class VisibilityIntMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class buildingType:
    @property
    def costTimeLocationInvariant(self)-> bool:
        ...

    @property
    def description(self)-> str:
        ...

    @property
    def name(self)-> str:
        ...

    def canBeEnqueued(self, number1: int, number2: int) -> bool:
        ...

    def canBeProduced(self, number1: int, number2: int) -> bool:
        ...

    def captureResult(self, number1: int, number2: int, number3: int, boolean: bool) -> captureResult:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """

    def perTurnCost(self, number1: int, number2: int) -> float:
        ...

    def productionCost(self, number1: int, number2: int) -> float:
        ...

    def productionTime(self, number1: int, number2: int) -> int:
        ...


class diplomaticMessage:
    @property
    def recipient(self)-> int:
        ...

    @property
    def sender(self)-> int:
        ...

    @property
    def type(self)-> diplomaticMessageType:
        ...


class diplomaticStatusUpdate:
    @property
    def empire1(self):
        ...

    @property
    def empire2(self):
        ...

    @property
    def status(self):
        ...


class empire:
    @property
    def allShipDesigns(self)-> IntSet:
        ...

    @property
    def availableBuildingTypes(self)-> StringSet:
        ...

    @property
    def availableShipDesigns(self)-> IntSet:
        ...

    @property
    def availableShipHulls(self)-> StringSet:
        ...

    @property
    def availableShipParts(self)-> StringSet:
        ...

    @property
    def availableTechs(self)-> StringSet:
        ...

    @property
    def capitalID(self)-> int:
        ...

    @property
    def colour(self)-> GGColor:
        ...

    @property
    def eliminated(self)-> bool:
        ...

    @property
    def empireID(self)-> int:
        ...

    @property
    def exploredSystemIDs(self)-> IntSet:
        ...

    @property
    def fleetSupplyableSystemIDs(self)-> IntSet:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def planetsWithAllocatedPP(self)-> resPoolMap:
        ...

    @property
    def planetsWithAvailablePP(self)-> resPoolMap:
        ...

    @property
    def planetsWithWastedPP(self)-> IntSetSet:
        ...

    @property
    def playerName(self)-> str:
        ...

    @property
    def productionPoints(self)-> float:
        ...

    @property
    def productionQueue(self)-> productionQueue:
        ...

    @property
    def researchQueue(self)-> researchQueue:
        ...

    @property
    def supplyUnobstructedSystems(self)-> IntSet:
        ...

    @property
    def systemSupplyRanges(self)-> IntFltMap:
        ...

    @property
    def won(self)-> bool:
        ...

    def buildingTypeAvailable(self, string: str) -> bool:
        ...

    def canBuild(self, build_type: buildType, string: str, number: int) -> bool:
        ...

    def getMeter(self, string: str) -> meter:
        """
        Returns the empire meter with the indicated name (string).
        """

    def getResourcePool(self, resource_type: resourceType) -> resPool:
        ...

    def getSitRep(self, number: int) -> sitrep:
        ...

    def getTechStatus(self, string: str) -> techStatus:
        ...

    def hasExploredSystem(self, number: int) -> bool:
        ...

    def numSitReps(self, number: int) -> int:
        ...

    def obstructedStarlanes(self) -> IntPairVec:
        ...

    def population(self) -> float:
        ...

    def preservedLaneTravel(self, number1: int, number2: int) -> bool:
        ...

    def productionCostAndTime(self, production_queue_element: productionQueueElement) -> object:
        ...

    def researchProgress(self, string: str) -> float:
        ...

    def resourceAvailable(self, resource_type: resourceType) -> float:
        ...

    def resourceProduction(self, resource_type: resourceType) -> float:
        ...

    def resourceStockpile(self, resource_type: resourceType) -> float:
        ...

    def shipDesignAvailable(self, number: int) -> bool:
        ...

    def supplyProjections(self) -> Dict[int, int]:
        ...

    def techResearched(self, string: str) -> bool:
        ...


class fieldType:
    @property
    def description(self)-> str:
        ...

    @property
    def name(self)-> str:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """


class shipHull:
    @property
    def costTimeLocationInvariant(self)-> bool:
        ...

    @property
    def fuel(self)-> float:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def numSlots(self)-> int:
        ...

    @property
    def slots(self)-> ShipSlotVec:
        ...

    @property
    def speed(self)-> float:
        ...

    @property
    def starlaneSpeed(self)-> float:
        ...

    @property
    def stealth(self)-> float:
        ...

    @property
    def structure(self)-> float:
        ...

    def hasTag(self, string: str) -> bool:
        ...

    def numSlotsOfSlotType(self, ship_slot_type: shipSlotType) -> int:
        ...

    def productionCost(self, number1: int, number2: int, number3: int) -> float:
        ...

    def productionLocation(self, number: int) -> bool:
        """
        Returns the result of Location condition (bool) in passed location_id (int)
        """

    def productionTime(self, number1: int, number2: int, number3: int) -> int:
        ...


class meter:
    @property
    def current(self)-> float:
        ...

    @property
    def initial(self)-> float:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """


class popCenter:
    @property
    def speciesName(self):
        ...


class productionQueue:
    @property
    def allocatedPP(self)-> resPoolMap:
        ...

    @property
    def empireID(self)-> int:
        ...

    @property
    def empty(self)-> bool:
        ...

    @property
    def size(self)-> int:
        ...

    @property
    def totalSpent(self)-> float:
        ...

    def __getitem__(self, number: int) -> productionQueueElement:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def availablePP(self, res_pool: resPool) -> resPoolMap:
        ...

    def objectsWithWastedPP(self, res_pool: resPool) -> IntSetSet:
        ...


class productionQueueElement:
    @property
    def allocation(self)-> float:
        ...

    @property
    def allowedStockpile(self)-> bool:
        ...

    @property
    def blocksize(self)-> int:
        ...

    @property
    def buildType(self)-> buildType:
        ...

    @property
    def designID(self)-> int:
        ...

    @property
    def locationID(self)-> int:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def paused(self)-> bool:
        ...

    @property
    def progress(self)-> float:
        ...

    @property
    def remaining(self)-> int:
        ...

    @property
    def turnsLeft(self)-> int:
        ...


class resPool:
    ...


class resPoolMap:
    def __contains__(self, obj: object) -> bool:
        ...

    def __delitem__(self, obj: object) -> None:
        ...

    def __getitem__(self, obj: object) -> object:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def __setitem__(self, obj1: object, obj2: object) -> None:
        ...


class researchQueue:
    @property
    def empireID(self)-> int:
        ...

    @property
    def empty(self)-> bool:
        ...

    @property
    def size(self)-> int:
        ...

    @property
    def totalSpent(self)-> float:
        ...

    def __contains__(self, research_queue_element: researchQueueElement) -> bool:
        ...

    def __getitem__(self, number: int) -> researchQueueElement:
        ...

    def __iter__(self) -> object:
        ...

    def __len__(self) -> int:
        ...

    def inQueue(self, string: str) -> bool:
        ...


class researchQueueElement:
    @property
    def allocation(self)-> float:
        ...

    @property
    def tech(self)-> str:
        ...

    @property
    def turnsLeft(self)-> int:
        ...


class resourceCenter:
    @property
    def availableFoci(self):
        ...

    @property
    def focus(self):
        ...

    @property
    def turnsSinceFocusChange(self):
        ...


class shipDesign:
    @property
    def attack(self)-> float:
        ...

    @property
    def attackStats(self)-> IntVec:
        ...

    @property
    def canColonize(self)-> bool:
        ...

    @property
    def canInvade(self)-> bool:
        ...

    @property
    def colonyCapacity(self)-> float:
        ...

    @property
    def costTimeLocationInvariant(self)-> bool:
        ...

    @property
    def defense(self)-> float:
        ...

    @property
    def description(self)-> str:
        ...

    @property
    def designedOnTurn(self)-> int:
        ...

    @property
    def detection(self)-> float:
        ...

    @property
    def fuel(self)-> float:
        ...

    @property
    def hasDirectWeapons(self)-> bool:
        ...

    @property
    def hasFighters(self)-> bool:
        ...

    @property
    def hull(self)-> str:
        ...

    @property
    def hull_type(self)-> hullType:
        ...

    @property
    def id(self)-> int:
        ...

    @property
    def industryGeneration(self)-> float:
        ...

    @property
    def isArmed(self)-> bool:
        ...

    @property
    def isMonster(self)-> bool:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def ship_hull(self) -> ship_hull:
        ...

    @property
    def parts(self)-> StringVec:
        ...

    @property
    def researchGeneration(self)-> float:
        ...

    @property
    def shields(self)-> float:
        ...

    @property
    def speed(self)-> float:
        ...

    @property
    def stealth(self)-> float:
        ...

    @property
    def structure(self)-> float:
        ...

    @property
    def tradeGeneration(self)-> float:
        ...

    @property
    def troopCapacity(self)-> float:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """

    def perTurnCost(self, number1: int, number2: int) -> float:
        ...

    def productionCost(self, number1: int, number2: int) -> float:
        ...

    def productionLocationForEmpire(self, number1: int, number2: int) -> bool:
        ...

    def productionTime(self, number1: int, number2: int) -> int:
        ...


class shipPart:
    @property
    def capacity(self)-> float:
        ...

    @property
    def costTimeLocationInvariant(self)-> bool:
        ...

    @property
    def mountableSlotTypes(self)-> ShipSlotVec:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def partClass(self)-> shipPartClass:
        ...

    @property
    def secondaryStat(self)-> float:
        ...

    def canMountInSlotType(self, ship_slot_type: shipSlotType) -> bool:
        ...

    def productionCost(self, number1: int, number2: int, number3: int) -> float:
        ...

    def productionLocation(self, number: int) -> bool:
        """
        Returns the result of Location condition (bool) in passed location_id (int)
        """

    def productionTime(self, number1: int, number2: int, number3: int) -> int:
        ...


class sitrep:
    @property
    def getTags(self):
        ...

    @property
    def getTurn(self)-> int:
        ...

    @property
    def typeString(self):
        ...

    def getDataIDNumber(self, string: str) -> int:
        ...

    def getDataString(self, string: str) -> str:
        ...


class special:
    @property
    def description(self)-> str:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def spawnlimit(self)-> int:
        ...

    @property
    def spawnrate(self)-> float:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """

    def initialCapacity(self, number: int) -> float:
        ...


class species:
    @property
    def canColonize(self)-> bool:
        ...

    @property
    def canProduceShips(self)-> bool:
        ...

    @property
    def description(self)-> str:
        ...

    @property
    def foci(self)-> StringVec:
        ...

    @property
    def homeworlds(self)-> IntSet:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def preferredFocus(self)-> str:
        ...

    @property
    def tags(self)-> StringSet:
        ...

    def dump(self, number: int) -> str:
        """
        Returns string with debug information, use '0' as argument.
        """

    def getPlanetEnvironment(self, planet_type: planetType) -> planetEnvironment:
        ...


class tech:
    @property
    def category(self)-> str:
        ...

    @property
    def description(self)-> str:
        ...

    @property
    def name(self)-> str:
        ...

    @property
    def prerequisites(self)-> StringSet:
        ...

    @property
    def shortDescription(self)-> str:
        ...

    @property
    def unlockedItems(self)-> UnlockableItemVec:
        ...

    @property
    def unlockedTechs(self)-> StringSet:
        ...

    def perTurnCost(self, number: int) -> float:
        ...

    def recursivePrerequisites(self, number: int) -> StringVec:
        ...

    def researchCost(self, number: int) -> float:
        ...

    def researchTime(self, number: int) -> int:
        ...


class universe:
    @property
    def allObjectIDs(self)-> IntVec:
        ...

    @property
    def buildingIDs(self)-> IntVec:
        ...

    @property
    def effectAccounting(self)-> TargetIDAccountingMapMap:
        ...

    @property
    def fieldIDs(self)-> IntVec:
        ...

    @property
    def fleetIDs(self)-> IntVec:
        ...

    @property
    def planetIDs(self)-> IntVec:
        ...

    @property
    def shipIDs(self)-> IntVec:
        ...

    @property
    def systemIDs(self)-> IntVec:
        ...

    def destroyedObjectIDs(self, number: int) -> IntSet:
        ...

    def dump(self) -> None:
        ...

    def getBuilding(self, number: int) -> building:
        ...

    def getField(self, number: int) -> field:
        ...

    def getFleet(self, number: int) -> fleet:
        ...

    def getGenericShipDesign(self, string: str) -> shipDesign:
        """
        Returns the ship design (ShipDesign) with the indicated name (string).
        """

    def getImmediateNeighbors(self, number1: int, number2: int) -> IntVec:
        ...

    def getObject(self, number: int) -> universeObject:
        ...

    def getPlanet(self, number: int) -> planet:
        ...

    def getShip(self, number: int) -> ship:
        ...

    def getSystem(self, number: int) -> system:
        ...

    def getSystemNeighborsMap(self, number1: int, number2: int) -> IntDblMap:
        ...

    def getVisibility(self, number1: int, number2: int) -> visibility:
        ...

    def getVisibilityTurnsMap(self, number1: int, number2: int) -> Dict[int, int]:
        ...

    def jumpDistance(self, number1: int, number2: int) -> int:
        """
        If two system ids are passed or both objects are within a system, return the jump distance between the two systems. If one object (e.g. a fleet) is on a starlane, then calculate the jump distance from both ends of the starlane to the target system and return the smaller one.
        """

    def leastJumpsPath(self, number1: int, number2: int, number3: int) -> IntVec:
        ...

    def linearDistance(self, number1: int, number2: int) -> float:
        ...

    def shortestNonHostilePath(self, number1: int, number2: int, number3: int) -> IntVec:
        """
        Shortest sequence of System ids and distance from System (number1) to System (number2) with no hostile Fleets as determined by visibility of Empire (number3).  (number3) must be a valid empire.
        """

    def shortestPath(self, number1: int, number2: int, number3: int) -> IntVec:
        ...

    def shortestPathDistance(self, number1: int, number2: int) -> float:
        ...

    def systemHasStarlane(self, number1: int, number2: int) -> bool:
        ...

    def systemsConnected(self, number1: int, number2: int, number3: int) -> bool:
        ...

    def updateMeterEstimates(self, obj: object) -> None:
        ...


class universeObject:
    @property
    def ageInTurns(self):
        ...

    @property
    def containedObjects(self):
        ...

    @property
    def containerObject(self):
        ...

    @property
    def creationTurn(self):
        ...

    @property
    def id(self):
        ...

    @property
    def meters(self):
        ...

    @property
    def name(self):
        ...

    @property
    def owner(self):
        ...

    @property
    def specials(self):
        ...

    @property
    def systemID(self):
        ...

    @property
    def tags(self):
        ...

    @property
    def unowned(self):
        ...

    @property
    def x(self):
        ...

    @property
    def y(self):
        ...

    def containedBy(self, number: int) -> bool:
        ...

    def contains(self, number: int) -> bool:
        ...

    def currentMeterValue(self, meter_type: meterType) -> float:
        ...

    def dump(self) -> str:
        """
        Returns string with debug information.
        """

    def getMeter(self, meter_type: meterType) -> meter:
        ...

    def hasSpecial(self, string: str) -> bool:
        ...

    def hasTag(self, string: str) -> bool:
        ...

    def initialMeterValue(self, meter_type: meterType) -> float:
        ...

    def ownedBy(self, number: int) -> bool:
        ...

    def specialAddedOnTurn(self, string: str) -> int:
        ...


class AccountingInfo(EffectCause):
    @property
    def meterChange(self):
        ...

    @property
    def meterRunningTotal(self):
        ...

    @property
    def sourceID(self):
        ...


class building(universeObject):
    @property
    def buildingTypeName(self)-> str:
        ...

    @property
    def orderedScrapped(self)-> bool:
        ...

    @property
    def planetID(self)-> int:
        ...

    @property
    def producedByEmpireID(self)-> int:
        ...


class field(universeObject):
    @property
    def fieldTypeName(self):
        ...

    def inField(self, base_object: universeObject) -> bool:
        ...


class fleet(universeObject):
    @property
    def aggressive(self)-> bool:
        ...

    @property
    def canChangeDirectionEnRoute(self)-> bool:
        ...

    @property
    def empty(self)-> bool:
        ...

    @property
    def finalDestinationID(self)-> int:
        ...

    @property
    def fuel(self)-> float:
        ...

    @property
    def hasArmedShips(self)-> bool:
        ...

    @property
    def hasColonyShips(self)-> bool:
        ...

    @property
    def hasFighterShips(self)-> bool:
        ...

    @property
    def hasMonsters(self)-> bool:
        ...

    @property
    def hasOutpostShips(self)-> bool:
        ...

    @property
    def hasTroopShips(self)-> bool:
        ...

    @property
    def maxFuel(self)-> float:
        ...

    @property
    def nextSystemID(self)-> int:
        ...

    @property
    def numShips(self)-> int:
        ...

    @property
    def previousSystemID(self)-> int:
        ...

    @property
    def shipIDs(self)-> IntSet:
        ...

    @property
    def speed(self)-> float:
        ...


class ship(universeObject):
    @property
    def arrivedOnTurn(self)-> int:
        ...

    @property
    def canBombard(self)-> bool:
        ...

    @property
    def canColonize(self)-> bool:
        ...

    @property
    def canInvade(self)-> bool:
        ...

    @property
    def colonyCapacity(self)-> float:
        ...

    @property
    def design(self)-> shipDesign:
        ...

    @property
    def designID(self)-> int:
        ...

    @property
    def fleetID(self)-> int:
        ...

    @property
    def hasFighters(self)-> bool:
        ...

    @property
    def isArmed(self)-> bool:
        ...

    @property
    def isMonster(self)-> bool:
        ...

    @property
    def lastResuppliedOnTurn(self)-> int:
        ...

    @property
    def lastTurnActiveInCombat(self)-> int:
        ...

    @property
    def orderedColonizePlanet(self)-> int:
        ...

    @property
    def orderedInvadePlanet(self)-> int:
        ...

    @property
    def orderedScrapped(self)-> bool:
        ...

    @property
    def partMeters(self)-> ShipPartMeterMap:
        ...

    @property
    def producedByEmpireID(self)-> int:
        ...

    @property
    def speciesName(self)-> str:
        ...

    @property
    def speed(self)-> float:
        ...

    @property
    def troopCapacity(self)-> float:
        ...

    def currentPartMeterValue(self, meter_type: meterType, string: str) -> float:
        ...

    def initialPartMeterValue(self, meter_type: meterType, string: str) -> float:
        ...


class system(universeObject):
    @property
    def buildingIDs(self)-> IntSet:
        ...

    @property
    def fieldIDs(self)-> IntSet:
        ...

    @property
    def fleetIDs(self)-> IntSet:
        ...

    @property
    def lastTurnBattleHere(self)-> int:
        ...

    @property
    def numStarlanes(self)-> int:
        ...

    @property
    def numWormholes(self)-> int:
        ...

    @property
    def planetIDs(self)-> IntSet:
        ...

    @property
    def shipIDs(self)-> IntSet:
        ...

    @property
    def starType(self)-> starType:
        ...

    @property
    def starlanesWormholes(self)-> IntBoolMap:
        ...

    def HasStarlaneToSystemID(self, number: int) -> bool:
        ...

    def HasWormholeToSystemID(self, number: int) -> bool:
        """
        Currently unused.
        """


class planet(universeObject, popCenter, resourceCenter):
    @property
    def InitialOrbitalPosition(self)-> float:
        ...

    @property
    def LastTurnAttackedByShip(self)-> int:
        ...

    @property
    def LastTurnConquered(self)-> int:
        ...

    @property
    def OrbitalPeriod(self)-> float:
        ...

    @property
    def RotationalPeriod(self)-> float:
        ...

    @property
    def buildingIDs(self)-> IntSet:
        ...

    @property
    def clockwiseNextPlanetType(self)-> planetType:
        ...

    @property
    def counterClockwiseNextPlanetType(self)-> planetType:
        ...

    @property
    def distanceFromOriginalType(self)-> int:
        ...

    @property
    def habitableSize(self)-> int:
        ...

    @property
    def nextLargerPlanetSize(self)-> planetSize:
        ...

    @property
    def nextSmallerPlanetSize(self)-> planetSize:
        ...

    @property
    def originalType(self)-> planetType:
        ...

    @property
    def size(self)-> planetSize:
        ...

    @property
    def type(self)-> planetType:
        ...

    def OrbitalPositionOnTurn(self, number: int) -> float:
        ...

    def environmentForSpecies(self, string: str) -> planetEnvironment:
        ...

    def nextBetterPlanetTypeForSpecies(self, string: str) -> planetType:
        ...


class Enum(int):
    """Enum stub for docs, not really present in fo"""
    def __new__(cls, *args, **kwargs):
        return super(Enum, cls).__new__(cls, args[0])


class aggression(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # aggression(invalid, "invalid")
    beginner = None  # aggression(beginner, "beginner")
    turtle = None  # aggression(turtle, "turtle")
    cautious = None  # aggression(cautious, "cautious")
    typical = None  # aggression(typical, "typical")
    aggressive = None  # aggression(aggressive, "aggressive")
    maniacal = None  # aggression(maniacal, "maniacal")


aggression.invalid = aggression(invalid, "invalid")
aggression.beginner = aggression(beginner, "beginner")
aggression.turtle = aggression(turtle, "turtle")
aggression.cautious = aggression(cautious, "cautious")
aggression.typical = aggression(typical, "typical")
aggression.aggressive = aggression(aggressive, "aggressive")
aggression.maniacal = aggression(maniacal, "maniacal")


class buildType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    building = None  # buildType(building, "building")
    ship = None  # buildType(ship, "ship")
    stockpile = None  # buildType(stockpile, "stockpile")


buildType.building = buildType(building, "building")
buildType.ship = buildType(ship, "ship")
buildType.stockpile = buildType(stockpile, "stockpile")


class captureResult(Enum):
    def __init__(self, numerator, name):
        self.name = name

    capture = None  # captureResult(capture, "capture")
    destroy = None  # captureResult(destroy, "destroy")
    retain = None  # captureResult(retain, "retain")


captureResult.capture = captureResult(capture, "capture")
captureResult.destroy = captureResult(destroy, "destroy")
captureResult.retain = captureResult(retain, "retain")


class diplomaticMessageType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    noMessage = None  # diplomaticMessageType(noMessage, "noMessage")
    warDeclaration = None  # diplomaticMessageType(warDeclaration, "warDeclaration")
    peaceProposal = None  # diplomaticMessageType(peaceProposal, "peaceProposal")
    acceptPeaceProposal = None  # diplomaticMessageType(acceptPeaceProposal, "acceptPeaceProposal")
    alliesProposal = None  # diplomaticMessageType(alliesProposal, "alliesProposal")
    acceptAlliesProposal = None  # diplomaticMessageType(acceptAlliesProposal, "acceptAlliesProposal")
    endAllies = None  # diplomaticMessageType(endAllies, "endAllies")
    cancelProposal = None  # diplomaticMessageType(cancelProposal, "cancelProposal")
    rejectProposal = None  # diplomaticMessageType(rejectProposal, "rejectProposal")


diplomaticMessageType.noMessage = diplomaticMessageType(noMessage, "noMessage")
diplomaticMessageType.warDeclaration = diplomaticMessageType(warDeclaration, "warDeclaration")
diplomaticMessageType.peaceProposal = diplomaticMessageType(peaceProposal, "peaceProposal")
diplomaticMessageType.acceptPeaceProposal = diplomaticMessageType(acceptPeaceProposal, "acceptPeaceProposal")
diplomaticMessageType.alliesProposal = diplomaticMessageType(alliesProposal, "alliesProposal")
diplomaticMessageType.acceptAlliesProposal = diplomaticMessageType(acceptAlliesProposal, "acceptAlliesProposal")
diplomaticMessageType.endAllies = diplomaticMessageType(endAllies, "endAllies")
diplomaticMessageType.cancelProposal = diplomaticMessageType(cancelProposal, "cancelProposal")
diplomaticMessageType.rejectProposal = diplomaticMessageType(rejectProposal, "rejectProposal")


class diplomaticStatus(Enum):
    def __init__(self, numerator, name):
        self.name = name

    war = None  # diplomaticStatus(war, "war")
    peace = None  # diplomaticStatus(peace, "peace")
    allied = None  # diplomaticStatus(allied, "allied")


diplomaticStatus.war = diplomaticStatus(war, "war")
diplomaticStatus.peace = diplomaticStatus(peace, "peace")
diplomaticStatus.allied = diplomaticStatus(allied, "allied")


class effectsCauseType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # effectsCauseType(invalid, "invalid")
    unknown = None  # effectsCauseType(unknown, "unknown")
    inherent = None  # effectsCauseType(inherent, "inherent")
    tech = None  # effectsCauseType(tech, "tech")
    building = None  # effectsCauseType(building, "building")
    field = None  # effectsCauseType(field, "field")
    special = None  # effectsCauseType(special, "special")
    species = None  # effectsCauseType(species, "species")
    shipPart = None  # effectsCauseType(shipPart, "shipPart")
    shipHull = None  # effectsCauseType(shipHull, "shipHull")


effectsCauseType.invalid = effectsCauseType(invalid, "invalid")
effectsCauseType.unknown = effectsCauseType(unknown, "unknown")
effectsCauseType.inherent = effectsCauseType(inherent, "inherent")
effectsCauseType.tech = effectsCauseType(tech, "tech")
effectsCauseType.building = effectsCauseType(building, "building")
effectsCauseType.field = effectsCauseType(field, "field")
effectsCauseType.special = effectsCauseType(special, "special")
effectsCauseType.species = effectsCauseType(species, "species")
effectsCauseType.shipPart = effectsCauseType(shipPart, "shipPart")
effectsCauseType.shipHull = effectsCauseType(shipHull, "shipHull")


class galaxySetupOption(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # galaxySetupOption(invalid, "invalid")
    none = None  # galaxySetupOption(none, "none")
    low = None  # galaxySetupOption(low, "low")
    medium = None  # galaxySetupOption(medium, "medium")
    high = None  # galaxySetupOption(high, "high")
    random = None  # galaxySetupOption(random, "random")


galaxySetupOption.invalid = galaxySetupOption(invalid, "invalid")
galaxySetupOption.none = galaxySetupOption(none, "none")
galaxySetupOption.low = galaxySetupOption(low, "low")
galaxySetupOption.medium = galaxySetupOption(medium, "medium")
galaxySetupOption.high = galaxySetupOption(high, "high")
galaxySetupOption.random = galaxySetupOption(random, "random")


class galaxyShape(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # galaxyShape(invalid, "invalid")
    spiral2 = None  # galaxyShape(spiral2, "spiral2")
    spiral3 = None  # galaxyShape(spiral3, "spiral3")
    spiral4 = None  # galaxyShape(spiral4, "spiral4")
    cluster = None  # galaxyShape(cluster, "cluster")
    elliptical = None  # galaxyShape(elliptical, "elliptical")
    disc = None  # galaxyShape(disc, "disc")
    box = None  # galaxyShape(box, "box")
    irregular = None  # galaxyShape(irregular, "irregular")
    ring = None  # galaxyShape(ring, "ring")
    random = None  # galaxyShape(random, "random")


galaxyShape.invalid = galaxyShape(invalid, "invalid")
galaxyShape.spiral2 = galaxyShape(spiral2, "spiral2")
galaxyShape.spiral3 = galaxyShape(spiral3, "spiral3")
galaxyShape.spiral4 = galaxyShape(spiral4, "spiral4")
galaxyShape.cluster = galaxyShape(cluster, "cluster")
galaxyShape.elliptical = galaxyShape(elliptical, "elliptical")
galaxyShape.disc = galaxyShape(disc, "disc")
galaxyShape.box = galaxyShape(box, "box")
galaxyShape.irregular = galaxyShape(irregular, "irregular")
galaxyShape.ring = galaxyShape(ring, "ring")
galaxyShape.random = galaxyShape(random, "random")


class meterType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    targetPopulation = None  # meterType(targetPopulation, "targetPopulation")
    targetIndustry = None  # meterType(targetIndustry, "targetIndustry")
    targetResearch = None  # meterType(targetResearch, "targetResearch")
    targetTrade = None  # meterType(targetTrade, "targetTrade")
    targetConstruction = None  # meterType(targetConstruction, "targetConstruction")
    targetHappiness = None  # meterType(targetHappiness, "targetHappiness")
    maxCapacity = None  # meterType(maxCapacity, "maxCapacity")
    maxDamage = None  # meterType(maxDamage, "maxDamage")
    maxSecondaryStat = None  # meterType(maxSecondaryStat, "maxSecondaryStat")
    maxFuel = None  # meterType(maxFuel, "maxFuel")
    maxShield = None  # meterType(maxShield, "maxShield")
    maxStructure = None  # meterType(maxStructure, "maxStructure")
    maxDefense = None  # meterType(maxDefense, "maxDefense")
    maxSupply = None  # meterType(maxSupply, "maxSupply")
    maxStockpile = None  # meterType(maxStockpile, "maxStockpile")
    maxTroops = None  # meterType(maxTroops, "maxTroops")
    population = None  # meterType(population, "population")
    industry = None  # meterType(industry, "industry")
    research = None  # meterType(research, "research")
    trade = None  # meterType(trade, "trade")
    construction = None  # meterType(construction, "construction")
    happiness = None  # meterType(happiness, "happiness")
    capacity = None  # meterType(capacity, "capacity")
    damage = None  # meterType(damage, "damage")
    secondaryStat = None  # meterType(secondaryStat, "secondaryStat")
    fuel = None  # meterType(fuel, "fuel")
    shield = None  # meterType(shield, "shield")
    structure = None  # meterType(structure, "structure")
    defense = None  # meterType(defense, "defense")
    supply = None  # meterType(supply, "supply")
    stockpile = None  # meterType(stockpile, "stockpile")
    troops = None  # meterType(troops, "troops")
    rebels = None  # meterType(rebels, "rebels")
    size = None  # meterType(size, "size")
    stealth = None  # meterType(stealth, "stealth")
    detection = None  # meterType(detection, "detection")
    speed = None  # meterType(speed, "speed")


meterType.targetPopulation = meterType(targetPopulation, "targetPopulation")
meterType.targetIndustry = meterType(targetIndustry, "targetIndustry")
meterType.targetResearch = meterType(targetResearch, "targetResearch")
meterType.targetTrade = meterType(targetTrade, "targetTrade")
meterType.targetConstruction = meterType(targetConstruction, "targetConstruction")
meterType.targetHappiness = meterType(targetHappiness, "targetHappiness")
meterType.maxCapacity = meterType(maxCapacity, "maxCapacity")
meterType.maxDamage = meterType(maxDamage, "maxDamage")
meterType.maxSecondaryStat = meterType(maxSecondaryStat, "maxSecondaryStat")
meterType.maxFuel = meterType(maxFuel, "maxFuel")
meterType.maxShield = meterType(maxShield, "maxShield")
meterType.maxStructure = meterType(maxStructure, "maxStructure")
meterType.maxDefense = meterType(maxDefense, "maxDefense")
meterType.maxSupply = meterType(maxSupply, "maxSupply")
meterType.maxStockpile = meterType(maxStockpile, "maxStockpile")
meterType.maxTroops = meterType(maxTroops, "maxTroops")
meterType.population = meterType(population, "population")
meterType.industry = meterType(industry, "industry")
meterType.research = meterType(research, "research")
meterType.trade = meterType(trade, "trade")
meterType.construction = meterType(construction, "construction")
meterType.happiness = meterType(happiness, "happiness")
meterType.capacity = meterType(capacity, "capacity")
meterType.damage = meterType(damage, "damage")
meterType.secondaryStat = meterType(secondaryStat, "secondaryStat")
meterType.fuel = meterType(fuel, "fuel")
meterType.shield = meterType(shield, "shield")
meterType.structure = meterType(structure, "structure")
meterType.defense = meterType(defense, "defense")
meterType.supply = meterType(supply, "supply")
meterType.stockpile = meterType(stockpile, "stockpile")
meterType.troops = meterType(troops, "troops")
meterType.rebels = meterType(rebels, "rebels")
meterType.size = meterType(size, "size")
meterType.stealth = meterType(stealth, "stealth")
meterType.detection = meterType(detection, "detection")
meterType.speed = meterType(speed, "speed")


class planetEnvironment(Enum):
    def __init__(self, numerator, name):
        self.name = name

    uninhabitable = None  # planetEnvironment(uninhabitable, "uninhabitable")
    hostile = None  # planetEnvironment(hostile, "hostile")
    poor = None  # planetEnvironment(poor, "poor")
    adequate = None  # planetEnvironment(adequate, "adequate")
    good = None  # planetEnvironment(good, "good")


planetEnvironment.uninhabitable = planetEnvironment(uninhabitable, "uninhabitable")
planetEnvironment.hostile = planetEnvironment(hostile, "hostile")
planetEnvironment.poor = planetEnvironment(poor, "poor")
planetEnvironment.adequate = planetEnvironment(adequate, "adequate")
planetEnvironment.good = planetEnvironment(good, "good")


class planetSize(Enum):
    def __init__(self, numerator, name):
        self.name = name

    unknown = None  # planetSize(unknown, "unknown")
    noWorld = None  # planetSize(noWorld, "noWorld")
    tiny = None  # planetSize(tiny, "tiny")
    small = None  # planetSize(small, "small")
    medium = None  # planetSize(medium, "medium")
    large = None  # planetSize(large, "large")
    huge = None  # planetSize(huge, "huge")
    asteroids = None  # planetSize(asteroids, "asteroids")
    gasGiant = None  # planetSize(gasGiant, "gasGiant")


planetSize.unknown = planetSize(unknown, "unknown")
planetSize.noWorld = planetSize(noWorld, "noWorld")
planetSize.tiny = planetSize(tiny, "tiny")
planetSize.small = planetSize(small, "small")
planetSize.medium = planetSize(medium, "medium")
planetSize.large = planetSize(large, "large")
planetSize.huge = planetSize(huge, "huge")
planetSize.asteroids = planetSize(asteroids, "asteroids")
planetSize.gasGiant = planetSize(gasGiant, "gasGiant")


class planetType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    unknown = None  # planetType(unknown, "unknown")
    swamp = None  # planetType(swamp, "swamp")
    toxic = None  # planetType(toxic, "toxic")
    inferno = None  # planetType(inferno, "inferno")
    radiated = None  # planetType(radiated, "radiated")
    barren = None  # planetType(barren, "barren")
    tundra = None  # planetType(tundra, "tundra")
    desert = None  # planetType(desert, "desert")
    terran = None  # planetType(terran, "terran")
    ocean = None  # planetType(ocean, "ocean")
    asteroids = None  # planetType(asteroids, "asteroids")
    gasGiant = None  # planetType(gasGiant, "gasGiant")


planetType.unknown = planetType(unknown, "unknown")
planetType.swamp = planetType(swamp, "swamp")
planetType.toxic = planetType(toxic, "toxic")
planetType.inferno = planetType(inferno, "inferno")
planetType.radiated = planetType(radiated, "radiated")
planetType.barren = planetType(barren, "barren")
planetType.tundra = planetType(tundra, "tundra")
planetType.desert = planetType(desert, "desert")
planetType.terran = planetType(terran, "terran")
planetType.ocean = planetType(ocean, "ocean")
planetType.asteroids = planetType(asteroids, "asteroids")
planetType.gasGiant = planetType(gasGiant, "gasGiant")


class resourceType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    industry = None  # resourceType(industry, "industry")
    trade = None  # resourceType(trade, "trade")
    research = None  # resourceType(research, "research")
    stockpile = None  # resourceType(stockpile, "stockpile")


resourceType.industry = resourceType(industry, "industry")
resourceType.trade = resourceType(trade, "trade")
resourceType.research = resourceType(research, "research")
resourceType.stockpile = resourceType(stockpile, "stockpile")


class roleType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    host = None  # roleType(host, "host")
    clientTypeModerator = None  # roleType(clientTypeModerator, "clientTypeModerator")
    clientTypePlayer = None  # roleType(clientTypePlayer, "clientTypePlayer")
    clientTypeObserver = None  # roleType(clientTypeObserver, "clientTypeObserver")
    galaxySetup = None  # roleType(galaxySetup, "galaxySetup")


roleType.host = roleType(host, "host")
roleType.clientTypeModerator = roleType(clientTypeModerator, "clientTypeModerator")
roleType.clientTypePlayer = roleType(clientTypePlayer, "clientTypePlayer")
roleType.clientTypeObserver = roleType(clientTypeObserver, "clientTypeObserver")
roleType.galaxySetup = roleType(galaxySetup, "galaxySetup")


class ruleType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # ruleType(invalid, "invalid")
    toggle = None  # ruleType(toggle, "toggle")
    int = None  # ruleType(int, "int")
    double = None  # ruleType(double, "double")
    string = None  # ruleType(string, "string")


ruleType.invalid = ruleType(invalid, "invalid")
ruleType.toggle = ruleType(toggle, "toggle")
ruleType.int = ruleType(int, "int")
ruleType.double = ruleType(double, "double")
ruleType.string = ruleType(string, "string")


class shipPartClass(Enum):
    def __init__(self, numerator, name):
        self.name = name

    shortRange = None  # shipPartClass(shortRange, "shortRange")
    fighterBay = None  # shipPartClass(fighterBay, "fighterBay")
    fighterHangar = None  # shipPartClass(fighterHangar, "fighterHangar")
    shields = None  # shipPartClass(shields, "shields")
    armour = None  # shipPartClass(armour, "armour")
    troops = None  # shipPartClass(troops, "troops")
    detection = None  # shipPartClass(detection, "detection")
    stealth = None  # shipPartClass(stealth, "stealth")
    fuel = None  # shipPartClass(fuel, "fuel")
    colony = None  # shipPartClass(colony, "colony")
    speed = None  # shipPartClass(speed, "speed")
    general = None  # shipPartClass(general, "general")
    bombard = None  # shipPartClass(bombard, "bombard")
    industry = None  # shipPartClass(industry, "industry")
    research = None  # shipPartClass(research, "research")
    trade = None  # shipPartClass(trade, "trade")
    productionLocation = None  # shipPartClass(productionLocation, "productionLocation")


shipPartClass.shortRange = shipPartClass(shortRange, "shortRange")
shipPartClass.fighterBay = shipPartClass(fighterBay, "fighterBay")
shipPartClass.fighterHangar = shipPartClass(fighterHangar, "fighterHangar")
shipPartClass.shields = shipPartClass(shields, "shields")
shipPartClass.armour = shipPartClass(armour, "armour")
shipPartClass.troops = shipPartClass(troops, "troops")
shipPartClass.detection = shipPartClass(detection, "detection")
shipPartClass.stealth = shipPartClass(stealth, "stealth")
shipPartClass.fuel = shipPartClass(fuel, "fuel")
shipPartClass.colony = shipPartClass(colony, "colony")
shipPartClass.speed = shipPartClass(speed, "speed")
shipPartClass.general = shipPartClass(general, "general")
shipPartClass.bombard = shipPartClass(bombard, "bombard")
shipPartClass.industry = shipPartClass(industry, "industry")
shipPartClass.research = shipPartClass(research, "research")
shipPartClass.trade = shipPartClass(trade, "trade")
shipPartClass.productionLocation = shipPartClass(productionLocation, "productionLocation")


class shipSlotType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    external = None  # shipSlotType(external, "external")
    internal = None  # shipSlotType(internal, "internal")
    core = None  # shipSlotType(core, "core")


shipSlotType.external = shipSlotType(external, "external")
shipSlotType.internal = shipSlotType(internal, "internal")
shipSlotType.core = shipSlotType(core, "core")


class starType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    unknown = None  # starType(unknown, "unknown")
    blue = None  # starType(blue, "blue")
    white = None  # starType(white, "white")
    yellow = None  # starType(yellow, "yellow")
    orange = None  # starType(orange, "orange")
    red = None  # starType(red, "red")
    neutron = None  # starType(neutron, "neutron")
    blackHole = None  # starType(blackHole, "blackHole")
    noStar = None  # starType(noStar, "noStar")


starType.unknown = starType(unknown, "unknown")
starType.blue = starType(blue, "blue")
starType.white = starType(white, "white")
starType.yellow = starType(yellow, "yellow")
starType.orange = starType(orange, "orange")
starType.red = starType(red, "red")
starType.neutron = starType(neutron, "neutron")
starType.blackHole = starType(blackHole, "blackHole")
starType.noStar = starType(noStar, "noStar")


class techStatus(Enum):
    def __init__(self, numerator, name):
        self.name = name

    unresearchable = None  # techStatus(unresearchable, "unresearchable")
    partiallyUnlocked = None  # techStatus(partiallyUnlocked, "partiallyUnlocked")
    researchable = None  # techStatus(researchable, "researchable")
    complete = None  # techStatus(complete, "complete")


techStatus.unresearchable = techStatus(unresearchable, "unresearchable")
techStatus.partiallyUnlocked = techStatus(partiallyUnlocked, "partiallyUnlocked")
techStatus.researchable = techStatus(researchable, "researchable")
techStatus.complete = techStatus(complete, "complete")


class unlockableItemType(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # unlockableItemType(invalid, "invalid")
    building = None  # unlockableItemType(building, "building")
    shipPart = None  # unlockableItemType(shipPart, "shipPart")
    shipHull = None  # unlockableItemType(shipHull, "shipHull")
    shipDesign = None  # unlockableItemType(shipDesign, "shipDesign")
    tech = None  # unlockableItemType(tech, "tech")


unlockableItemType.invalid = unlockableItemType(invalid, "invalid")
unlockableItemType.building = unlockableItemType(building, "building")
unlockableItemType.shipPart = unlockableItemType(shipPart, "shipPart")
unlockableItemType.shipHull = unlockableItemType(shipHull, "shipHull")
unlockableItemType.shipDesign = unlockableItemType(shipDesign, "shipDesign")
unlockableItemType.tech = unlockableItemType(tech, "tech")


class visibility(Enum):
    def __init__(self, numerator, name):
        self.name = name

    invalid = None  # visibility(invalid, "invalid")
    none = None  # visibility(none, "none")
    basic = None  # visibility(basic, "basic")
    partial = None  # visibility(partial, "partial")
    full = None  # visibility(full, "full")


visibility.invalid = visibility(invalid, "invalid")
visibility.none = visibility(none, "none")
visibility.basic = visibility(basic, "basic")
visibility.partial = visibility(partial, "partial")
visibility.full = visibility(full, "full")


def allEmpireIDs()  -> IntVec:
    """
    Returns an object (intVec) that contains the empire IDs of all empires in the game.
    """


def allPlayerIDs()  -> IntVec:
    """
    Returns an object (intVec) that contains the player IDs of all players in the game.
    """


def appendFleetMoveOrder(number1: int, number2: int)  -> int:
    """
    Orders the fleet with indicated fleetID (int) to append the system with the indicated destinationID (int) to its possibly already enqueued route. Returns 1 (int) on success or 0 (int) on failure due to not finding the indicated fleet or system.
    """


def currentTurn()  -> int:
    """
    Returns the current game turn (int).
    """


def empireID()  -> int:
    """
    Returns the empire ID (int) of this AI player's empire.
    """


def empirePlayerID(number: int)  -> int:
    """
    Returns the player ID (int) of the player who is controlling the empire with the indicated empireID (int).
    """


def getAIDir()  -> str:
    ...


def getBuildingType(string: str)  -> buildingType:
    """
    Returns the building type (BuildingType) with the indicated name (string).
    """


def getEmpire(number: int)  -> empire:
    """
    Returns the empire object (Empire) of this AI player
    Returns the empire object (Empire) with the specified empire ID (int)
    """


def getFieldType(string: str)  -> fieldType:
    ...


def getGalaxySetupData()  -> GalaxySetupData:
    ...


def getGameRules()  -> GameRules:
    """
    Returns the game rules manager, which can be used to look up the names (string) of rules are defined with what type (boolean / toggle, int, double, string), and what values the rules have in the current game.
    """


def getShipHull(string: str)  -> shipHull:
    """
    Returns the ship hull (shipHull) with the indicated name (string).
    """


def getOptionsDBOptionBool(string: str)  -> object:
    """
    Returns the bool value of option in OptionsDB or None if the option does not exist.
    """


def getOptionsDBOptionDouble(string: str)  -> object:
    """
    Returns the double value of option in OptionsDB or None if the option does not exist.
    """


def getOptionsDBOptionInt(string: str)  -> object:
    """
    Returns the integer value of option in OptionsDB or None if the option does not exist.
    """


def getOptionsDBOptionStr(string: str)  -> object:
    """
    Returns the string value of option in OptionsDB or None if the option does not exist.
    """


def getOrders()  -> OrderSet:
    """
    Returns the orders the client empire has issued (OrderSet).
    """


def getPredefinedShipDesign(string: str)  -> shipDesign:
    """
    Returns the ship design (ShipDesign) with the indicated name (string).
    """


def getSaveStateString()  -> str:
    """
    Returns the previously-saved state string (string). Can be used to retrieve the last-set save state string at any time, although this string is also passed to the resumeLoadedGame(savedStateString) Python function when a game is loaded, so this function isn't necessary to use if resumeLoadedGame stores the passed string.
    """


def getShipDesign(number: int)  -> shipDesign:
    """
    Returns the ship design (ShipDesign) with the indicated id number (int).
    """


def getShipPart(string: str)  -> shipPart:
    """
    Returns the ShipPart with the indicated name (string).
    """


def getSpecial(string: str)  -> special:
    """
    Returns the special (Special) with the indicated name (string).
    """


def getSpecies(string: str)  -> species:
    """
    Returns the species (Species) with the indicated name (string).
    """


def getTech(string: str)  -> tech:
    """
    Returns the tech (Tech) with the indicated name (string).
    """


def getTechCategories(obj: object)  -> StringVec:
    """
    Returns the names of all tech categories (StringVec).
    """


def getUniverse()  -> universe:
    """
    Returns the universe object (Universe)
    """


def getUserConfigDir()  -> str:
    """
    Returns path to directory where FreeOrion stores user specific configuration.
    """


def getUserDataDir()  -> str:
    """
    Returns path to directory where FreeOrion stores user specific data (saves, etc.).
    """


def initMeterEstimatesDiscrepancies()  -> None:
    ...


def issueAggressionOrder(number: int, boolean: bool)  -> int:
    ...


def issueAllowStockpileProductionOrder(number: int, boolean: bool)  -> int:
    """
    Orders the item on the production queue at index queueIndex (int) to be enabled (or disabled) to use the imperial stockpile. Returns 1 (int) on success or 0 (int) on failure if the queue index is less than 0 or greater than the largest indexed item on the queue.
    """


def issueBombardOrder(number1: int, number2: int)  -> int:
    ...


def issueChangeFocusOrder(number: int, string: str)  -> int:
    """
    Orders the planet with ID planetID (int) to use focus setting focus (string). Returns 1 (int) on success or 0 (int) on failure if the planet can't be found or isn't owned by this player, or if the specified focus is not valid on the planet.
    """


def issueChangeProductionQuantityOrder(number1: int, number2: int, number3: int)  -> int:
    ...


def issueColonizeOrder(number1: int, number2: int)  -> int:
    """
    Orders the ship with ID shipID (int) to colonize the planet with ID planetID (int). Returns 1 (int) on success or 0 (int) on failure due to not finding the indicated ship or planet, this client's player not owning the indicated ship, the planet already being colonized, or the planet and ship not being in the same system.
    """


def issueCreateShipDesignOrder(string1: str, string2: str, string3: str, item_list: list, string4: str, string5: str, boolean: bool)  -> int:
    """
    Orders the creation of a new ship design with the name (string), description (string), hull (string), parts vector partsVec (StringVec), graphic (string) and model (string). model should be left as an empty string as of this writing. There is currently no easy way to find the id of the new design, though the client's empire should have the new design after this order is issued successfully. Returns 1 (int) on success or 0 (int) on failure if any of the name, description, hull or graphic are empty strings, if the design is invalid (due to not following number and type of slot requirements for the hull) or if creating the design fails for some reason.
    """


def issueDequeueProductionOrder(number: int)  -> int:
    """
    Orders the item on the production queue at index queueIndex (int) to be removed form the production queue. Returns 1 (int) on success or 0 (int) on failure if the queue index is less than 0 or greater than the largest indexed item on the queue.
    """


def issueDequeueTechOrder(string: str)  -> int:
    """
    Orders the tech with name techName (string) to be removed from the queue. Returns 1 (int) on success or 0 (int) on failure if the indicated tech can't be found. Will return 1 (int) but do nothing if the indicated tech isn't on this player's empire's tech queue.
    """


def issueEnqueueBuildingProductionOrder(string: str, number: int)  -> int:
    """
    Orders the building with name (string) to be added to the production queue at the location of the planet with id locationID. Returns 1 (int) on success or 0 (int) on failure if there is no such building or it is not available to this player's empire, or if the building can't be produced at the specified location.
    """


def issueEnqueueShipProductionOrder(number1: int, number2: int)  -> int:
    """
    Orders the ship design with ID designID (int) to be added to the production queue at the location of the planet with id locationID (int). Returns 1 (int) on success or 0 (int) on failure there is no such ship design or it not available to this player's empire, or if the design can't be produced at the specified location.
    """


def issueEnqueueTechOrder(string: str, number: int)  -> int:
    """
    Orders the tech with name techName (string) to be added to the tech queue at position (int) on the queue. Returns 1 (int) on success or 0 (int) on failure if the indicated tech can't be found. Will return 1 (int) but do nothing if the indicated tech can't be enqueued by this player's empire.
    """


def issueFleetMoveOrder(number1: int, number2: int)  -> int:
    """
    Orders the fleet with indicated fleetID (int) to move to the system with the indicated destinationID (int). Returns 1 (int) on success or 0 (int) on failure due to not finding the indicated fleet or system.
    """


def issueFleetTransferOrder(number1: int, number2: int)  -> int:
    """
    Orders the ship with ID shipID (int) to be transferred to the fleet with ID newFleetID. Returns 1 (int) on success, or 0 (int) on failure due to not finding the fleet or ship, or the client's empire not owning either, or the two not being in the same system (or either not being in a system) or the ship already being in the fleet.
    """


def issueGiveObjectToEmpireOrder(number1: int, number2: int)  -> int:
    ...


def issueInvadeOrder(number1: int, number2: int)  -> int:
    ...


def issueNewFleetOrder(string: str, number: int)  -> int:
    """
    Orders a new fleet to be created with the indicated name (string) and containing the indicated shipIDs (IntVec). The ships must be located in the same system and must all be owned by this player. Returns the new fleets id (int) on success or 0 (int) on failure due to one of the noted conditions not being met.
    """


def issuePauseProductionOrder(number: int, boolean: bool)  -> int:
    """
    Orders the item on the production queue at index queueIndex (int) to be paused (or unpaused). Returns 1 (int) on success or 0 (int) on failure if the queue index is less than 0 or greater than the largest indexed item on the queue.
    """


def issueRenameOrder(number: int, string: str)  -> int:
    """
    Orders the renaming of the object with indicated objectID (int) to the new indicated name (string). Returns 1 (int) on success or 0 (int) on failure due to this AI player not being able to rename the indicated object (which this player must fully own, and which must be a fleet, ship or planet).
    """


def issueRequeueProductionOrder(number1: int, number2: int)  -> int:
    """
    Orders the item on the production queue at index oldQueueIndex (int) to be moved to index newQueueIndex (int). Returns 1 (int) on success or 0 (int) on failure if the old and new queue indices are equal, if either queue index is less than 0 or greater than the largest indexed item on the queue.
    """


def issueScrapOrder(number: int)  -> int:
    """
    Orders the ship or building with the indicated objectID (int) to be scrapped. Returns 1 (int) on success or 0 (int) on failure due to not finding a ship or building with the indicated ID, or if the indicated ship or building is not owned by this AI client's empire.
    """


def playerEmpireID(number: int)  -> int:
    """
    Returns the empire ID (int) of the player with the specified player ID (int).
    """


def playerID()  -> int:
    """
    Returns the integer id of this AI player.
    """


def playerIsAI(number: int)  -> bool:
    """
    Returns True (boolean) if the player with the indicated playerID (int) is controlled by an AI and false (boolean) otherwise.
    """


def playerIsHost(number: int)  -> bool:
    """
    Returns True (boolean) if the player with the indicated playerID (int) is the host player for the game and false (boolean) otherwise.
    """


def playerName(number: int)  -> str:
    """
    Returns the name (string) of the player with the indicated playerID (int).
    Returns the name (string) of this AI player.
    """


def sendChatMessage(number: int, string: str)  -> None:
    """
    Sends the indicated message (string) to the player with the indicated recipientID (int) or to all players if recipientID is -1.
    """


def sendDiplomaticMessage(diplomatic_message: diplomaticMessage)  -> None:
    ...


def setSaveStateString(string: str)  -> None:
    """
    Sets the save state string (string). This is a persistant storage space for the AI script to retain state information when the game is saved and reloaded. Any AI state information to be saved should be stored in a single string (likely using Python's pickle module) and stored using this function when the prepareForSave() Python function is called.
    """


def techs()  -> StringVec:
    ...


def techsInCategory(string: str)  -> StringVec:
    ...


def updateMeterEstimates(boolean: bool)  -> None:
    ...


def updateProductionQueue()  -> None:
    ...


def updateResearchQueue()  -> None:
    ...


def updateResourcePools()  -> None:
    ...


def userString(string: str)  -> str:
    ...


def userStringExists(string: str)  -> bool:
    ...


def userStringList(string: str)  -> list:
    ...


def validShipDesign(string: str, string_list: StringVec)  -> bool:
    """
    Returns true (boolean) if the passed hull (string) and parts (StringVec) make up a valid ship design, and false (boolean) otherwise. Valid ship designs don't have any parts in slots that can't accept that type of part, and contain only hulls and parts that exist (and may also need to contain the correct number of parts - this needs to be verified).
    """
